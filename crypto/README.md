# 🔑 Time-based One-Time Password (TOTP)

[`🦕 Playground`](https://dash.deno.com/playground/libs-totp)

This library is based on the well-written article of [@rajat-sr](https://github.com/rajat-sr) on [hackernoon](https://hackernoon.com) :

- [How To Implement Google Authenticator Two Factor Auth in JavaScript](https://hackernoon.com/how-to-implement-google-authenticator-two-factor-auth-in-javascript-091wy3vh3)

Their explanation was specifically intended for NodeJS so I rewrote it to make it compatible with native Web APIs. Additionally, the URL scheme for TOTP was implemented, and combined with the QR Code generator library it can be used to make it scannable with with an authenticator
app such as [Microsoft Authenticator](https://support.microsoft.com/en-us/account-billing/download-and-install-the-microsoft-authenticator-app-351498fc-850a-45da-b7b6-27e523b8702a) or
[Google Authenticator](https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2&pli=1).

## Features

- Issue a new TOTP secret with metadata (issuer, account, image, etc.)
- No external dependencies
- Lightweight

## Usage

```ts
import { otpauth, otpsecret, verify } from "./totp.ts"
import { qrcode } from "./../qrcode/mod.ts"

// Issue a new TOTP secret
const secret = otpsecret()
const url = otpauth({ issuer: "example.com", account: "alice", secret })
console.log(`Please scan the following QR Code:`)
qrcode(url.href, { output: "console" })

// Verify a TOTP token
const token = prompt("Please enter the token generated by your app:")!
console.assert(await verify({ token, secret }))
```

# 🔐 Symmetric encryption (using AES-GCM 256 with a PBKDF2 derived key)

[`🦕 Playground`](https://dash.deno.com/playground/libs-encryption)

This library is inspired by existing password managers, where the aim is to provide a secure way to store credentials at rest (for example in a [`Deno.Kv` store](https://docs.deno.com/deploy/kv/manual)) while being able to recover them later using a single master key.

Here, it is achieved by using [`AES-GCM 256-bits`](https://en.wikipedia.org/wiki/Galois/Counter_Mode) with [`PBKDF2`](https://en.wikipedia.org/wiki/PBKDF2) derived key. The latter could for instance use a username as `salt` and a password as `seed` to consistently forge back the
key and decrypt the stored credentials. These are provided by the native [`Web Crypto`](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) APIs.

This library also adds additional features such as data integrity and original length obfuscation. It _**does not**_ re-implement cryptographic primitives, it just provides a convenient way to use them.

> [!CAUTION]\
> As explained in the [license](/LICENSE):
>
> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
>
> The author is not responsible for any damage that could be caused by the use of this library. It is your responsibility to use it properly and to understand the security implications of the choices you make.

## Features

- Use native [`Web Crypto`](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) APIs
- Use [`AES-GCM 256-bits`](https://en.wikipedia.org/wiki/Galois/Counter_Mode) with [`PBKDF2`](https://en.wikipedia.org/wiki/PBKDF2) derived key to encrypt and decrypt messages
  - Encrypted messages are different each time thanks to [initialization vector](https://en.wikipedia.org/wiki/Initialization_vector)
  - The derived key from a given `seed`/`password` are always the same
- Added functionalities which also introduce additional entropy:
  - With [SHA-256](https://en.wikipedia.org/wiki/SHA-2) to guarantee integrity
  - With stored size to guarantee integrity _(for messages with length < 255)_
  - With padding to force length be `256` or `512` bytes and obfuscate the original size _(can be disabled using `0` as value)_

## Usage

```ts
import { decrypt, encrypt, exportKey, importKey } from "./encryption.ts"

// Generate a key. Same seed and salt combination will always yield the same key
const key = await exportKey({ seed: "hello", salt: "world" })
console.assert(key === "664d43091e7905723fc92a4c38f58e9aeff6d822488eb07d6b11bcfc2468f48a")

// Encrypt a message
const message = "🍱 bento"
const secret = await encrypt(message, { key, length: 512 })
console.assert(secret !== message)

// Encrypted messages are different each time and can also obfuscate the original message size
console.assert(secret !== await encrypt(message, { key, length: 512 }))
console.assert(secret.length === 512)

// Decrypt a message
const decrypted = await decrypt(secret, { key })
console.assert(decrypted === message)
```
